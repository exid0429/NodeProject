

/*
변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 이렇게 되면 파이선이나 자바에서는 참조 에러를 일으키겠지만
JS에서는 Undefined가 출력된다. Why?
변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런 타임이 아니라 그 이전 단계에서 먼저 선언이
실행되기 때문이다.
JS엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서(런타임) 소스코드의 평가 과정을 거치면서 소스코드를 진행
하기 위한 준비를 하는데, 이 과정에서 변수 선언을 포함한 모든 선언문(변수, 함수선언문) 을 소스코드에서 찾아내
먼저 실행한다. 이 평가 과정이 긑나면 선언문을 제외하고 코드를 실행한다.

이처럼 변수 선언문이 코드의 제일 먼저로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 
변수 호이스팅이라고 한다.
변수 선언뿐만이 아니라, var,let,const,function,function*,class 전부다 그럼

변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값을 
새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 곳에 값을 저장한다는 것을 잊지마.
할당하는 과정에서 같은 주소에서 값만 바꾸는게 아니라, 새로운 주소를 할당받는거라, 할당 받은 이후의
값에 있는 주소는 쓸모가 없어진다. 이런 불필요한 값들은 가비지 컬렉터에 의해서 메모레에서 자동헤체된다.

상수는 단 한 번만 할당할 수 있는 변수.

값(value) => 식(표현식)이 평가되어 생성된 결과. 평가란 식을 해석해서 값을 생성하거나 참조하는 것.
변수 => 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

리터럴 => 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
5 => 숫자 리터럴 5(리터럴은 평가되어 값을 생성한다.)
런타임에 리터럴을 평가해 값을 생성한다.

표현식 값으로 평가될 수 있는 문. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
리터럴도 표현식

문 => 프로그램을 구성하는 기본 단위이자 최소 실행 단위 , 문+문+문....=>프로그램

var x; //변수 선언문
x = 5; // 할당문
function foo() {} // 함수 선언문
if(x>1) { console.log(x+x)}; //조건문
for(var i=0; i<2; i++) {console.log(i);} //반복문

원시타입은 단 하나의 값만 나타내지만 , 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조이다.
원시값은 변경 불가능한 값이지만 객체는 변경 가능한 값이다.
객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

프로퍼티 값이 함수일 경우, 메서드라 부른다.
객체 = 프로퍼티 + 메서드
프로퍼티 => 객체의 상태를 나타내는 값(data)
메서드 => 프로퍼티(상태 데이터)를 참조하고 조작할수 있는 동작(behavior)

함수로 객체를 생성하기도 하고, 함수 자체가 객체이기도 하다.
인스턴스 => 클래스에 의해 생성되어 메모리에 저장된 실체. 
객체 생성방법
1.객체 리터럴
var perosn = {
    name : 'Lee',
    sayHello: function() {
        console.log(`Hello! My name is ${this.name}.`);
    }
};

console.log(typeof person); //object
객체 리터럴의 중괄호는 코드 블록이 아니다. 

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.
2.Object 생성자 함수
3.생성자 함수
4.Object.create 메서드
5.클래스(es6)

문자열 또는 문자열로 평가할수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성 할 수도 있다.
이때는 []로 묶어야함.
var obj = {};
var key = 'hello';

obj[key] = ' world';
es6버전으로하면
var obj = { [key] : 'world'};

-프로퍼티에 접근하는 방법은 2가지다.
마침표 표기법 / 대괄표 표기법
var person = {
    name : 'Lee'
};

console.log(person.name);
console.log(person['name']);

---- 
es6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티
키를 생략할 수 있다.

let x=1, y=2;
var obj = { x, y};
메서드 축약 표현
const obj = {
    name : 'Lee',
    sayHi() {
        console.log('Hi' + this.name);
    }
};

obj.sayHi();

원시타입 => 데이터 타입( 숫자, 문자열, 불리언, null , undefined , 심벌)
객체타입 => 저거빼고 다.

원시값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 객체를 변수에 
할당하면 변수에는 참조 값(주소)이 저장된다.
원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달 => 값에 의한 전달
객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값(주소)가 복사되어 전달
=>참조에 의한 전달

변수 => 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
값 => 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과 .
원시 값을 할당한 변수에 새로운 원시 값을 재할당하게 되면 메모리 공간에 저장되어 있는 재할당 이전의 원시값을 변경하는것이 아니라,
세로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리키는데,
이때 변수가 참조하던 메모리 공간의 주소가 바뀐다.

- 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 비슷한 기능을 쓸순있다. 그렇지만 메서드는 못 써.
var str = 'String';

console.log(str[0]); 인덱스를 사용해 접근이 가능
console.log(str.length); 6
console.log(str.toupperCase()); // STRING

str[0] = 'a';
문자열은 유사 배열이므로 인덱스로 문자에 접근할수는 있는데 문자열은
원시값이라서 값을 바꿀수는 없어. 조회만 가능하단거지.
기억해! 원시값은 값을 바꿀수가 없다.
str = 'ABa'; 이렇게 새롭게 바꾼다면 'Aba'를 메모리에 생성하고 저걸 가리키게 변경하는것.
재할당은 되도 값의 일부를 바꿀수는 없다는 뜻.

---
원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시값에 접근할 수 있다.
원시값을 할당한 변수는 원시값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리주소를 통해
메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소다.
변수는 참조 값을 통해 객체에 접근할 수 있다.




*/

console.log(score); // undefined

score = 80;
var score;

console.log(score); // 무엇이 출력이 될까?, 80  


