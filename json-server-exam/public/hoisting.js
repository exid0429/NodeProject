

/*
변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 이렇게 되면 파이선이나 자바에서는 참조 에러를 일으키겠지만
JS에서는 Undefined가 출력된다. Why?
변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런 타임이 아니라 그 이전 단계에서 먼저 선언이
실행되기 때문이다.
JS엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서(런타임) 소스코드의 평가 과정을 거치면서 소스코드를 진행
하기 위한 준비를 하는데, 이 과정에서 변수 선언을 포함한 모든 선언문(변수, 함수선언문) 을 소스코드에서 찾아내
먼저 실행한다. 이 평가 과정이 긑나면 선언문을 제외하고 코드를 실행한다.

이처럼 변수 선언문이 코드의 제일 먼저로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 
변수 호이스팅이라고 한다.
변수 선언뿐만이 아니라, var,let,const,function,function*,class 전부다 그럼

변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값을 
새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 곳에 값을 저장한다는 것을 잊지마.
할당하는 과정에서 같은 주소에서 값만 바꾸는게 아니라, 새로운 주소를 할당받는거라, 할당 받은 이후의
값에 있는 주소는 쓸모가 없어진다. 이런 불필요한 값들은 가비지 컬렉터에 의해서 메모레에서 자동헤체된다.

상수는 단 한 번만 할당할 수 있는 변수.

값(value) => 식(표현식)이 평가되어 생성된 결과. 평가란 식을 해석해서 값을 생성하거나 참조하는 것.
변수 => 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

리터럴 => 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
5 => 숫자 리터럴 5(리터럴은 평가되어 값을 생성한다.)
런타임에 리터럴을 평가해 값을 생성한다.

표현식 값으로 평가될 수 있는 문. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
리터럴도 표현식

문 => 프로그램을 구성하는 기본 단위이자 최소 실행 단위 , 문+문+문....=>프로그램

var x; //변수 선언문
x = 5; // 할당문
function foo() {} // 함수 선언문
if(x>1) { console.log(x+x)}; //조건문
for(var i=0; i<2; i++) {console.log(i);} //반복문

원시타입은 단 하나의 값만 나타내지만 , 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조이다.
원시값은 변경 불가능한 값이지만 객체는 변경 가능한 값이다.
객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

프로퍼티 값이 함수일 경우, 메서드라 부른다.
객체 = 프로퍼티 + 메서드
프로퍼티 => 객체의 상태를 나타내는 값(data)
메서드 => 프로퍼티(상태 데이터)를 참조하고 조작할수 있는 동작(behavior)

함수로 객체를 생성하기도 하고, 함수 자체가 객체이기도 하다.
인스턴스 => 클래스에 의해 생성되어 메모리에 저장된 실체. 
객체 생성방법


*/

console.log(score); // undefined

score = 80;
var score;

console.log(score); // 무엇이 출력이 될까?, 80  


