/*
함수는 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.
함수를 사용함으로써
1) 코드의 재사용이라는 측면에서 좋고
2) 유지보수의 편의성
3) 코드의 신뢰성을 높이고
4) 코드의 가독성 향상

*/

/* 함수 리러털
함수 이름 : 식별자, 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자.
함수 몸체 : 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록.
함수 리터럴도 값을 생성하며, 이 값은 객체이다. 함수는 객체.
일반 객체와 다른점은 일반 객체는 호출을 할 수 없지만, 함수는 가능하다.
*/
var f = function add(x,y) {
    return x + y;
};

/* 
함수 선언문
함수 선언문은 리러털이랑 형태는 똑같은데 함수이름을 생략할수 없음(당연한거지 ! 함수 이름이 없으면 어떻게 부를거야?)
함수선언문은 표현식이 아닌 문이기때문에 브라우저에서 선언하면 undefined가 출력된다.
표현식이 아닌 문은 값에 할당 할 수 없음. 
이런데...

*/
function add(x,y) {
    return x + y;
}
/*
함수 선언문은 표현식이 아닌 문이므로 변수에 할당 할 수없는데.... 이거보면 할당한거처럼 보이네 왜?
JS 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와
표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.
함수 선언문은 함수 이름이 생략 안되는거만 빼면 리터럴이랑 형태가 똑같다. 똑같다!
즉 함수 이름이 있는 함수 선언문은  함수 선언문이 될수도 있고 표현식인 문인
함수리터럴 표현식으로 해석될 수도 있다.

*/
var add = function add(x,y) {
    return x + y;
}

//이건 함수 선언문
function foo() { console.log('foo'); }
foo();

//함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
//함수 리터럴에서는 함수 이름 생략 가능
(function bar() { console.log('bar');});
bar(); // ReferenceError : bar is not defined.
/*함수 리터럴에서 함수이름은 함수 몸체 내에서만 참조할 수 있는 식별자이기 떄문에 에러가 뜬다.
foo는 되는 이유는 자스 엔진이 암묵적으로 생성한 식별자이기 때문이다.
엔진은 함수 선언문을 해석해 함수 객체를 생성한다. 쟈스 엔진은 생성된 함수를 호출하기 위해
함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 객체를 할당한다.
함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
함수는 일급객체(값처럼 변수에 할당가능, 프로퍼티 값이 될수도 있고 배열의 요소가 될수도 있다.)

함수리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이걸 함수 표현식이라함

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 그러나 함수 표현식으로
정의한 함수는 함수 표현식 이전에 호출할 수 없다.

*/

//함수 표현식
var add = function add(x,y) {
    return x + y;
};

//Function 생성자 함수
var add = new Function('x','y', 'return x + y' );

//화살표 함수(es6)
var add = (x,y) => x + y;

